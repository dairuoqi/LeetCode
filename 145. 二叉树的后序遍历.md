#### 145. 二叉树的后序遍历

```
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]

```
思路一：
* 先采用根右左的遍历方法
* 将结果翻转

```
#define SIZE 20000
int* postorderTraversal(struct TreeNode* root, int* returnSize){
    int *node = (int *)malloc (sizeof(int) * 1000);
    *returnSize = 0;
    struct TreeNode *p = root;
    struct TreeNode* stack[SIZE];
    int top = -1;
    while (p || top > -1) {
        if(p) {
            stack[++top] = p;
             node[(*returnSize)++] = p -> val;
            p = p -> right; 
        } else {
            p = stack[top--];
            p = p -> left;
        }
    }
    for(int i = 0; i < *returnSize / 2; i++) {
        int temp = node[i];
        node[i] = node[*returnSize - i - 1];
        node[*returnSize - i - 1] = temp;
    }
    return node;
}
```

思路二：
* 建立一个指向前一节点的指针，标记右孩子是否被访问

```
#define SIZE 20000
int* postorderTraversal(struct TreeNode* root, int* returnSize){
    int *node = (int *)malloc (sizeof(int) * 1000);
    *returnSize = 0;
    struct TreeNode *p = root;
    struct TreeNode *pre = NULL;
    struct TreeNode* stack[SIZE];
    int top = -1;
    while (p || top > -1) {
        if(p) {
            stack[++top] = p;
            p = p -> left; 
        } else {
            p = stack[top];
            if (p -> right == pre || p -> right == NULL) {
                node[(*returnSize)++] = p -> val;
                top--;
                pre = p;
                p = NULL;
            } else  p = p -> right;
        }
    }
    return node;
}
```
